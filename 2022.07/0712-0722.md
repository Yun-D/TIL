## 220712 ~ 0722 TIL💭

---
## 텍스트 생략 시에만 더보기 버튼 나오게 하기
- 요소의 `clientWidth(clientHeight)`와 `scrollWidth(scrollHeight)` 비교하기
- 이를 위해 요소에 `ref`속성을 넣어 직접 접근

--- 

#### 7/15 
- 다만 지금 프로젝트에는 데이터를 Map으로 보여주고 있어서 그런지 가장 마지막 데이터에만 접근이 가능했음.
	- 이것을 위해 ref를 배열로도 만들어봤으나 undefined나 사용할 수 없는 데이터만을 출력했음..
	- 여기서 무한 삽질..

#### 7/19
- 원하는 것 : 
	1. postDummy 데이터를 map()으로 복사한다.
	2. 데이터가 복사되어 렌더링 될 때 마다 ref로 참조한다.
	3. 참조 시 마다 useEffect()를 이용해(postRef가 변경될 때 마다 실행) PostContents의 clientHeight, scrollHeight를 가져와 비교한다.
	4. 비교하여 cH가 sH보다 크다면 state를 변경한다.
	5. 렌더링 될 때 마다 변경된 state에 따라 더보기 버튼을 출력한다.

- 현재 상황 : 
	1. map으로 복사되어 텍스트 데이터는 정상 출력된다.
	2. 위 내용에 2번이 제대로 동작하지 않는다. 렌더링이 모두 완료되고나서 마지막 데이터의 내용이 postDummy 데이터 length 배열만큼 반복되어 삽입된다.

- 살펴봐야할 사항(7/20 계획)
	- postRef.current가 왜 반복되는가?
      - map()과 렌더 타이밍이 관련 있는지 확인
   - styled-components의 문제인가?
   - 배열에 넣는 타이밍 문제?

#### 7/20
- 알아낸 것
	- "useRef로 만들어진 객체는 React가 만든 전역 저장소에 저장되기 때문에 함수를 재호출 하더라도 마지막으로 업데이트한 current값이 유지됩니다"
		- 그래서 마지막 업뎃된 current값으로 적용되는 것?

	- "ref를 수정하는 작업은 componentDidMount 또는 componentDidUpdate 생명주기 메서드가 호출되기 전 이루어집니다."
		- 그렇다는건.. map()으로 ref배열을 만들든 말든 useEffect에서 만지는 값들은 마운트되기 전에 이미 마지막 current 값으로 고정이 됐다는 것으로 추측됨.


- 적용해볼 점
	- 그렇다면.. map()을 부모컴포넌트에서 해준다면? data는 prop으로 넘기고 부모컴포넌트에서 ref를 따서 useEffect에서 감시하면 가능하지않을까?


#### 7/22
- 알아낸 것
	- 20일에 도출한 가설이 맞았다!! map은 부모 컴포넌트 수준에서 자식을 복사해야 맞는 것이었음. 왜 이생각을 못 하고 있었지!?
	- 자식에서 map 했을 때 => 텍스트 자체를 복붙해주긴 하지만 각각이 떨어진 객체가 아니었기 때문에 그저 함수 재호출 형식이 된 것. 따라서 마지막으로 업데이트한 current값으로 고정되어 출력된 것!!

- **배운 것**
	- 생명주기 타이밍이 헷갈릴 때나 생각한 메커니즘대로 작동하지 않으면 공식 문서를 보자..